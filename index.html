<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>7セグメント風デジタル時計</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        /* --- 全体の設定 --- */
        body {
            background-color: #000;
            color: #00ff00;
            font-family: 'Share Tech Mono', monospace;
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            text-align: center;
        }

        /* --- マトリックス背景用キャンバス --- */
        #matrix-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* 時計より背面に */
        }

        /* --- 時計のコンテナ --- */
        .clock-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%; /* 画面幅いっぱいに */
            z-index: 1; /* マトリックスより手前に */
        }

        /* --- 7セグメント表示エリア --- */
        .segment-display-area {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 25px;
        }

        .segment-char {
            display: grid;
            grid-template-areas:
                ". a ."
                "f . b"
                ". g ."
                "e . c"
                ". d .";
            grid-template-columns: 0.15fr 1fr 0.15fr;
            grid-template-rows: 0.15fr 1fr 0.15fr 1fr 0.15fr;
            width: 9vw;
            height: 16vw;
            max-width: 70px;
            max-height: 120px;
            margin: 0 0.8vw;
            position: relative;
        }

        .segment {
            background-color: #2a2a2a;
            border-radius: 3px;
            transition: background-color 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
        }

        .segment.on {
            background-color: #00ff00;
            box-shadow: 0 0 8px #00ff00, 0 0 15px #00ff00, 0 0 3px #fff inset;
        }

        /* 各セグメントの位置と形状 */
        .seg-a { grid-area: a; height: 100%; margin: 0 5%;}
        .seg-g { grid-area: g; height: 100%; margin: 0 5%;}
        .seg-d { grid-area: d; height: 100%; margin: 0 5%;}

        .seg-b { grid-area: b; width: 100%; margin: 5% 0; justify-self: end;}
        .seg-c { grid-area: c; width: 100%; margin: 5% 0; justify-self: end;}
        .seg-e { grid-area: e; width: 100%; margin: 5% 0; justify-self: start;}
        .seg-f { grid-area: f; width: 100%; margin: 5% 0; justify-self: start;}


        .colon {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            align-items: center;
            width: 3.5vw;
            height: 16vw;
            max-width: 25px;
            max-height: 120px;
            margin: 0 0.3vw;
        }
        .colon-dot {
            width: 1.8vw;
            height: 1.8vw;
            max-width: 12px;
            max-height: 12px;
            background-color: #00ff00;
            border-radius: 50%;
            box-shadow: 0 0 8px #00ff00, 0 0 15px #00ff00;
        }

        /* --- 日付の表示 (テキスト) --- */
        .date-display {
            font-size: 3.8vw;
            letter-spacing: 0.1vw;
            text-shadow: 0 0 8px #00ff00, 0 0 15px #00ff00;
            margin-top: 15px;
        }
        @media (max-width: 768px) { /* タブレット */
            .segment-char { width: 11vw; height: 20vw; max-width: 60px; max-height: 100px; margin: 0 0.6vw;}
            .colon { width: 4vw; height: 20vw; max-width: 20px; max-height: 100px;}
            .date-display { font-size: 4.5vw; }
        }
        @media (max-width: 480px) { /* スマートフォン */
            .segment-char { width: 14vw; height: 25vw; max-width: 50px; max-height: 85px; margin: 0 0.4vw;}
            .colon { width: 5vw; height: 25vw; max-width: 15px; max-height: 85px;}
            .date-display { font-size: 5.5vw; }
        }

    </style>
</head>
<body>
<canvas id="matrix-canvas"></canvas>
<div class="clock-container">
    <div class="segment-display-area" id="time-display-area">
    </div>
    <div class="date-display" id="date-display">YYYY/MM/DD</div>
</div>

<script>
    // --- 7セグメントのパターン ---
    const segmentPatterns = {
        '0': ['a', 'b', 'c', 'd', 'e', 'f'],
        '1': ['b', 'c'],
        '2': ['a', 'b', 'g', 'e', 'd'],
        '3': ['a', 'b', 'g', 'c', 'd'],
        '4': ['f', 'g', 'b', 'c'],
        '5': ['a', 'f', 'g', 'c', 'd'],
        '6': ['a', 'f', 'g', 'e', 'c', 'd'],
        '7': ['a', 'b', 'c'],
        '8': ['a', 'b', 'c', 'd', 'e', 'f', 'g'],
        '9': ['a', 'b', 'g', 'f', 'c', 'd']
    };

    // --- 7セグメント文字を生成する関数 ---
    function createSegmentChar(digit) {
        const charDiv = document.createElement('div');
        charDiv.classList.add('segment-char');
        const segments = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
        segments.forEach(seg => {
            const segDiv = document.createElement('div');
            segDiv.classList.add('segment', `seg-${seg}`);
            charDiv.appendChild(segDiv);
        });
        updateSegmentChar(charDiv, digit);
        return charDiv;
    }

    // --- 7セグメント文字を更新する関数 ---
    function updateSegmentChar(charDiv, digit) {
        const pattern = segmentPatterns[digit] || [];
        const segments = charDiv.querySelectorAll('.segment');
        segments.forEach(segDiv => {
            const segIdentifier = segDiv.classList[1].split('-')[1];
            if (pattern.includes(segIdentifier)) {
                segDiv.classList.add('on');
            } else {
                segDiv.classList.remove('on');
            }
        });
    }

    // --- コロンを生成する関数 ---
    function createColon() {
        const colonDiv = document.createElement('div');
        colonDiv.classList.add('colon');
        const dot1 = document.createElement('div');
        dot1.classList.add('colon-dot');
        const dot2 = document.createElement('div');
        dot2.classList.add('colon-dot');
        colonDiv.appendChild(dot1);
        colonDiv.appendChild(dot2);
        return colonDiv;
    }

    const timeDisplayArea = document.getElementById('time-display-area');
    const dateDisplay = document.getElementById('date-display');
    const timeChars = [];

    for (let i = 0; i < 6; i++) {
        const charElement = createSegmentChar('0');
        timeChars.push(charElement);
        timeDisplayArea.appendChild(charElement);
        if (i === 1 || i === 3) {
            timeDisplayArea.appendChild(createColon());
        }
    }

    function updateClock() {
        const now = new Date();
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const seconds = String(now.getSeconds()).padStart(2, '0');
        const timeString = hours + minutes + seconds;

        for (let i = 0; i < timeString.length; i++) {
            if (timeChars[i]) {
                updateSegmentChar(timeChars[i], timeString[i]);
            }
        }

        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        dateDisplay.textContent = `${year}/${month}/${day}`;
    }
    setInterval(updateClock, 1000);
    updateClock();

    // --- マトリックス背景機能 ---
    const canvas = document.getElementById('matrix-canvas');
    const ctx = canvas.getContext('2d');
    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    const matrixChars = "アァカサタナハマヤャラワガザダバパイィキシチニヒミリヰギジヂビピウゥクスツヌフムユュルグズブヅプエェケセテネヘメレヱゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッン0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    const charsArray = matrixChars.split('');
    const fontSize = 16; // 文字サイズは変更なし
    let columns = Math.floor(width / fontSize);

    const drops = [];
    const highlightPosition = [];

    function initializeMatrixColumns() {
        columns = Math.floor(window.innerWidth / fontSize);
        drops.length = 0;
        highlightPosition.length = 0;
        for (let x = 0; x < columns; x++) {
            drops[x] = 1 + Math.floor(Math.random() * (height / fontSize));
            highlightPosition[x] = Math.floor(Math.random() * (height / fontSize));
        }
    }
    initializeMatrixColumns();

    // アニメーション速度調整用
    let lastTime = 0;
    const fps = 15; // 1秒あたりのフレーム数 (数値を小さくすると遅くなる)
    const interval = 1000 / fps;

    function drawMatrix(timestamp) { // timestamp を引数に追加
        if (timestamp - lastTime < interval) { // 前回の描画からの時間がinterval未満なら描画しない
            requestAnimationFrame(drawMatrix);
            return;
        }
        lastTime = timestamp; // 最終描画時間を更新

        ctx.fillStyle = 'rgba(0, 0, 0, 0.08)'; // 背景のフェードアウトを少し濃くして、文字が残る時間を短く
        ctx.fillRect(0, 0, width, height);
        ctx.font = fontSize + 'px Share Tech Mono, monospace';

        for (let i = 0; i < drops.length; i++) {
            if (!drops[i]) continue;

            const text = charsArray[Math.floor(Math.random() * charsArray.length)];
            const xPos = i * fontSize;
            const yPos = drops[i] * fontSize;

            // yPos が画面外に出たら、ランダムな確率で上に戻す
            if (yPos > height && Math.random() > 0.985) { // 戻る確率を少し下げる (ゆっくり消えるように)
                drops[i] = 0;
                highlightPosition[i] = Math.floor(Math.random() * (height / fontSize));
            }
            drops[i]++;

            // ハイライト文字の輝度を調整
            if (drops[i] -1 === highlightPosition[i]) {
                ctx.fillStyle = '#88FF88'; // ハイライトの色を少し暗めに (例: 明るい緑 -> 通常の緑)
                ctx.shadowColor = '#BBFFBB'; // 影の色も調整
                ctx.shadowBlur = 5;      // 影のぼかしを少し弱く
            } else {
                // 通常文字の輝度を調整
                ctx.fillStyle = '#00AA00'; // 通常の色を少し暗めに (例: 緑 -> 暗い緑)
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            }
            ctx.fillText(text, xPos, yPos);
        }
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        // requestAnimationFrame(drawMatrix); // animateMatrix関数内で呼び出すように変更
    }

    window.addEventListener('resize', () => {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        initializeMatrixColumns();
    });

    function animateMatrix(timestamp) { // timestamp を引数に追加
        drawMatrix(timestamp); // drawMatrix に timestamp を渡す
        requestAnimationFrame(animateMatrix);
    }
    // animateMatrix(); // 最初の呼び出しは引数なしでOK (timestampはrequestAnimationFrameが自動で渡す)
    requestAnimationFrame(animateMatrix); // 最初の呼び出し
</script>
</body>
</html>
